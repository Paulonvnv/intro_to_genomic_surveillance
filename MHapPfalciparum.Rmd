---
title: "*AMPLseq*: Targeted amplicon sequencing panel for *Plasmodium falciparum*"
author: "Neafsey Lab"
output:
  html_document:
    toc: yes
    number_sections: no
    toc_float: yes
    code_folding: show
editor_options:
  markdown:
    wrap: 72
  chunk_output_type: inline
---

The purpose of this tutorial is to introduce researchers at Neafsey Lab
in the analysis of genotypic information of *Plasmodium falciparum*
generated through the targeted amplicon sequencing panel AMPLseq. This
tutorial will cover:

1.  Importing and handling tables in CIGAR format in R environment.

2.  Adding metadata.

3.  Performance of the genotyping process.

4.  Molecular surveillance of drug resistance.

5.  Monitoring transmission intensity.

6.  Measuring geographic connectivity.

In this tutorial we will use a data set of 1300 samples distributed
across 8 sequencing runs as a example. These samples comes from a
collaboration with the group of Caucaseco, which has collected samples
of *P. falciparum* from 2020 to 2022 in 5 municipalities located in
Colombia. The data set has geographic information, however this
information is encoded to protect the origin of the participants.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Importing and handling tables in CIGAR format in R environment

Our first step will be to call all required packages and functions in
the R environment:

```{r 'Loading required packages and functions'}
source('docs/functions_and_libraries/amplseq_required_libraries.R')
source('docs/functions_and_libraries/amplseq_functions.R')
sourceCpp('docs/functions_and_libraries/hmmloglikelihood.cpp')
sourceCpp('docs/functions_and_libraries/Rcpp_functions.cpp')
```

This tutorial start with .tsv table in CIGAR format that has been
generated by the
[malaria-amplicon-pipeline](https://github.com/broadinstitute/malaria-amplicon-pipeline)
of our lab. The output of this pipeline has the following structure:

$\begin{array}{c|c:c:c:c:c:c} \text{sampleID}&Gene_1,Allele_1&Gene_1,Allele_2&...&Gene_1,Allele_k&... & Gene_m, Allele_{k_m}\\ \hline ID_1 & \text{Read counts} &&& \\ \hdashline ... &&&&\\ \hdashline ID_n &&&& \end{array}$

Where the $Allele$ is coded in Pseudo-CIGAR format, typing "." for the
reference allele, $[0-9]*[A,T,C,G]$ for each point mutation observed,
and $[0-9]*[D,I]=[A,T,C,G]*$ for indels (Insertions and Deletions). The
numbers before the letters denotes the position in the amplicon where
the polymorphism is located

These Pseudo-CIGAR tables are stored in the server of the lab using the
following path structure:

`"STUDYNAME/RUNNAME/dada2/run_dada2/CIGARVariants.out.tsv"`

As this structure is maintained across all studies in the lab, we have
created a function called `read_cigar_tables` that only requires two
arguments: `paths` (name of the folder of the study or the `STUDYNAME`),
and `sample_id_pattern` (a pattern string in the IDs of the samples that
differentiate them from controls). In case you don't want to
differentiate samples from controls, set this argument equals to `"."`.
For this particular example, the path will be `"data/sequencing_data/"`
, while the pattern will be `"ID"`. In case all `".tvs"` files are
stored in one folder, you can use the argument `files = list_of_files`
instead of the argument `paths`, where `list_of_files` is a vector with
the names of all files we want to read.

```{r 'Uploading data sets'}
cigar_object = read_cigar_tables(paths = "docs/data/Pfal_sequencing_data", sample_id_pattern = "ID")
```

This function generates a S4 cigar object containing two data.frames, 1)
a `cigar_table`, where genotyping information is stored in cigar format;
and 2) a `metadata` table with 4 variables (columns), **a)** `Sample_id`
which contains samples Id's; **b)** `run` which contains the run number
(or the name of the folter where the fastq's for that run wehere
stored), information that is useful for comparing performance across
batches of samples; **c)** `order_in_plate`, useful to identify rare
amplifications patterns in the plate; and **d)** `typeofSamp` which
differentiates between controls and samples of interest. In order to
view these tables use `View(cigar_table$cigar_table)` or
`View(cigar_table$metadata)` in the console.

**NOTE:** If there are duplicated samples, only the replicated with the
highest read depth across all loci will be kept.

## Adding Metadata

Metadata would come from different sources, sometimes the sample ID
incorporates metadata in their coding system, other times metadata can
be stored in a different table, having one column specifying the sample
ID. In the case of this data set, we will perform the analysis at the
level of Municipality and in intervals of three months starting from the
first day of collection of samples. Then, to add sampling location,
month of collection and other metadata we are going to merge (using the
function `left_join()`) our `metadata` table in the `cigar_object` to a
metadata table from an external source that contain all the metadata
associated with these samples. Thus, we will upload a metadata table
from an external source. For this purpose we are going to import the
file called `metadata.csv` into our R environment.

```{r 'Adding Population'}
# Upload metadata from an external source
metadata = read.csv('docs/data/Pfal_metadata.csv')

# Merge the external metadata with our cigar_object
cigar_object@metadata = left_join(cigar_object@metadata,
                              metadata,
                              by = 'Sample_id')
```

We can use ggplot2 to plot the sample size (number of genotyped samples)
by Municipality over time.

```{r 'Ploting the number of collected samples by Municipality over time'}

# Define the temporal unit of analysis
dates = sort(unique(cigar_object@metadata$Quarter_of_Collection))

# Define the geographic unite of analysis
pop_levels = levels(as.factor(cigar_object@metadata$Subnational_level2))
pop_colors = c("firebrick3", "dodgerblue3", "gold3", "darkseagreen3", "lightsalmon2")

plot_temporal_collection_of_samples = cigar_object@metadata %>%
  filter(!is.na(Subnational_level2)) %>% # Remove samples with no geographic information (Controls)
  summarise(nsamples= n(), .by = c(Subnational_level2, Quarter_of_Collection))%>%
  ggplot(aes(x = Quarter_of_Collection, y = nsamples, fill = factor(Subnational_level2,
                                                              levels = pop_levels)))+
  geom_col()+
  theme_bw()+
  scale_fill_manual(values = pop_colors)+
  facet_wrap(.~factor(Subnational_level2,
                      levels = pop_levels),
             strip.position = "top", ncol = 5)+
  labs(title = 'Number of Samples collected over time',
       y = "Collected samples by PCD",
       x = "Quarter")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position =  "none")+
  scale_x_discrete(limits = dates)

plot_temporal_collection_of_samples
```

## Performance of the genotyping process

A first step in analyzing the genotypic data is to measure the
performance of the genotyping process in terms of the proportion of
samples amplified by each locus (amplification rate by locus) and the
proportion of loci amplified per each sample (amplification rate per
sample). In order to perform that task, we are going to convert our
cigar table to a more manageable (easy to read for the user) format
called ampseq format, where amplicons or genes are going to be in
columns, samples in rows, and the allele in cigar format is going to be
in each cell of the matrix together with the read count of that allele
in the sample.

$\begin{array}{c|c:c:c:c} \text{sampleID}&Gene_1&Gene_2&...& Gene_m\\ \hline ID_1 & Allele_{i_{i \in Alleles_{Gene_1}}}\text{:Read count} &&& \\ \hdashline ... &&&&\\ \hdashline ID_n &&&& \end{array}$

For that purpose we are going to use the function `cigar2ampseq`. This
function requires 4 arguments. First a `cigar_object` (containing the
cigar_table and the metadata). Then `markers`, which is a table with the
set of markers and their names (in a column named `amplicon`). This
argument is optional, and in case is `NULL`, the name of the amplicons
will be extracted from the columns in the `cigar_object`, but
information regarding chormosome location (information required to
stimaed reladness under the hmmIBD algorithm) and length of the amplicon
will be missing. The next arguments are `min_abd` and `min_ratio`, which
are the minimum abundance (minimum read count) required to call an
allele and the minimum ratio between the minor and major alleles in a
polyclonal sample. By default these two arguments are 10 and 0.1
respectively. The last argument is `remove_controls`, by default is
`FALSE`, but if change ti `TRUE` the information of the controls will be
stored in a separated slot. Thus, this function automatically
differentiate between controls and samples of interest, and its output
is a `ampseq_object` S4 list with 6 slots: `gt` where the genotypic
information of the samples of interest is stored in a `ampseq` format;
the `metadata` of the samples of interest; `controls` with all the
information of the controls; `markers` containing the information of the
markers such as the chromosome location; and other empty slots required
for the next steps such as `loci_performance` and `pop_summary`.

```{r "Generating a ampseq object"}
# (alleles and abundance will be in cells)
markers = read.csv("docs/reference/Pfal_3D7/markers.csv")
ampseq = cigar2ampseq(cigar_object, markers = markers, min_abd = 10, min_ratio = .1, remove_controls = T)
```

### Removing PCR artefacts

There are some artifacts that the `dada2` pipeline doesn't resolve well
like the generation of chimeras (artificial fusion of two different
haplotypes during the PCR amplification) in polyclonal samples. That is
the case of the alleles `PF3D7_1302900,1G` and `PF3D7_0612900,215A` that
are observed in polyclonal infections only. So we are going to proceed
to remove both alleles from our `cigar_table`. Additionally, `PvDHFR`
locus was amplified in order to detect mixed infections with *Plasmodium
vivax*, so we are going to remove this locus too as this locus is not of
our interest in this tutorial.

```{r}
allele_count_frac_ofHet_pAlt = frac_ofHet_pAlt_byAllele(ampseq)
```

```{r}
allele_count_frac_ofHet_pAlt %>%
  ggplot(aes(x = p_ij, 
               y = h_ij,
               color = h_ijminor,
               size = dVSITES_ij,
               shape = flanking_INDEL
               ))+
    geom_point()+
    theme_bw()+
    scale_color_continuous(type = 'viridis')+
  #facet_grid(flanking_INDEL~h_ijminor_cat)+
    labs(x = 'Alternative allele frequency (p_ij)',
         y = 'h_ij (H_ij/P_ij)',
         color = 'h_ijminor')
```

```{r 'Removing artifacts and Pvivax control locus'}
ampseq@gt = mask_alt_alleles(ampseq, mask_formula = "h_ij >= 0.75 & h_ijminor >= 0.75")
```

### Read depth coverage

Once the data has been converted to the ampseq format, we can explore
the read depth coverage by sample and by marker, and make comparisons
between treatments, geographic regions or sequencing runs. For that we
can use the function `plot_coverage()` which requires two arguments, the
`ampseq` object and the `variable` from metadata that we want to use to
split the information.

```{r, fig.height= 15}
ampseq@metadata$TotalReadDepth = sample_TotalReadDepth(ampseq)

pcr_plate = data.frame(order_in_plate = 1:192,
                       pcr_col = rep(rep(1:12, each = 8), 2),
                       pcr_row = rep(rep(LETTERS[1:8], 12), 2))

ampseq@metadata = left_join(ampseq@metadata, pcr_plate, by = 'order_in_plate')

ampseq@metadata %>%
  ggplot(aes(x = as.factor(pcr_col), y = factor(pcr_row, levels = LETTERS[8:1]), fill = TotalReadDepth))+
  geom_tile(color = 'black')+
  facet_wrap(.~run, ncol = 1, scales = 'free_x')+
  theme_bw()+
  labs(x = 'Columns',
       y = 'Rows')+
  scale_fill_gradient(low = "white", high = "firebrick")

```

```{r 'Describing the read depth coverage by run and study site'}
coverage_by_municipality = plot_coverage(ampseq, variable = "Subnational_level2")
```

The output of this function is a list with three plots

1.  A heatmap of the read depth (color intensity) of every marker
    (x-axis) and every sample (y-axis) by category of the chosen
    variable (panels)

```{r, fig.height=12, fig.width=8}
coverage_by_municipality$plot_read_depth_heatmap
```

2.  A Jitter-Violin plot of the read depth (y-axis in log10 scale) of
    every marker and every sample (dots) by category of the chosen
    variable (x-axis)

```{r}
coverage_by_municipality$plot_read_depth_violin 
```

3.  A Jitter-Violin plot of the total read depth (y-axis in log10 scale)
    of every sample (dots) by category of the chosen variable (x-axis)

```{r}
coverage_by_municipality$plot_read_depth_violin_by_sample 
```

### Amplification rate by locus

We can also use the function `loci_amplification_rate` to measure the
proportion of samples that have been amplified by each amplicon marker.
This function requires two arguments, the `ampseq_object` and
`threshold`, which defines the minimum proportion of samples that a
marker should amplify in order to be keep it for further analysis
(default 0.65). All markers below this `threshold` will be removed and
stored in a different slot in our object.

```{r 'Filtering loci of low amplification rate'}
ampseq_filtered = locus_amplification_rate(ampseq, threshold = .65)
```

Thus in this data set `r ncol(ampseq@gt)` loci had an amplification rate
above 0.65, and `r ncol(ampseq_filtered@discarded_loci$gt)` loci were
discarded. All discarded loci are stored in the slot `discarded_loci`
within the `ampseq_object`. The discarded loci were:
`r paste(colnames(ampseq@discarded_loci$gt), collapse = ', ')`.

```{r 'Ploting loci performance', fig.width=7, fig.height=7, fig.cap= '**Figure 2:** Proportion of amplified samples per locus. Top figure shows the distribution of the amplification rate (or proportion of amplified samples) of loci, with the number of loci in the y-axis and the amplification rate in the x-axis. Bottom figure shows the the chromosome location of each locus (chromosomes in y-axis and position in the x-axis) and the gradient color represents its amplification rate.'}
# Plot Amplification rate per loci ----

ggdraw()+
  draw_plot(ampseq_filtered@plots$amplification_rate_per_locus,
            x = 0,
            y = 0,
            width = 1,
            height = .5)+
  draw_plot(ampseq_filtered@plots$all_loci_amplification_rate,
            x = 0,
            y = .5,
            width = 1,
            height = .5)
```

### Amplification rate by sample

The next step is to measure the proportion of loci amplified per each
sample, also called the amplification rate of the samples. For that
purpose we are going to use the function `sample_amplification_rate`
that also requires only two arguments, the `ampseq_object` and a
`threshold`, which is the minmum proportion of loci that a sample should
amplified (by default 0.8).

```{r 'Filtering samples of low amplification rate', fig.width=5, fig.height=5, fig.cap='**Figure 3:** Proportion of amplified loci per sample. The figure shows the distribution of the amplification rate (or proportion of amplified loci) of the samples, with the number of samples in the y-axis and the amplification rate in the x-axis.'}

ampseq_filtered = sample_amplification_rate(ampseq_filtered, threshold = .8)

ampseq_filtered@plots$samples_amplification_rate+
         theme(axis.text = element_text(size = 12),
               axis.title = element_text(size = 12))

```

## Molecular surveillance of drug resistance

Surveillance of polymorphisms or allelic variants associated with
resistance against antimalarials is of the utmost importance in public
health. That is why our panel of markers includes 5 genes (9 markers in
total, some genes are genotyped by more than one marker) that have
polymorphisms associated with antimalarial resistance. In this section
we will identify the different haplotypes of these genes present in our
data set, and we will determine the frequency of each haplotype in each
study area and in each quarter of the year. For this we will use the
function `drug_resistant_haplotypes` which has 7 arguments. The first
argument is the `ampseq_object`. The second is a table with the
reference alleles for each gene, and the polymorphisms associated with
resistance. The structure of this table is as follows:

$$\begin{array}{c|c:c:c} \text{Chromosome} & \text{Gene_ID} & \text{Description} & \text{Mutation} & \text{Anotation} \\ \text{Pf3D7_04_v3} & \text{PF3D7_0417200} & dhfr & \text{N51I} & \text{Pyrimethamine resistance} \\ ... \end{array}$$

Where the mutation describes the reference amino acid (sensitive to the
drug), the position in the amino acid chain, and finally the amino acid
associated with resistance.

The third and fourth arguments refer to the common name of the gene (or
the name by which it is identified in the `markers` table in the
`ampseq_object`) and the gene ID in the gff file of the referential
strain (in this case strain 3D7). The fifth and sixth arguments are the
.gff and .fasta files of the genome of the reference strain, and the
last argument, `variables`, is a vector that has the columns of the
`metadata` table that will be used to define the subpopulations and
generate the report graph. For this particular example we will define as
`variables = c('Sample_id', 'Subnational_level2', 'Quarter_of_Collection')`,
where `Sample_id`, is the column that we will use to map the data,
`Subnational_level2` is the column to define the area of study, and
`Quarter_of_Collection` defines the time scale.

The function generates a list with 3 tables and a graph. The first table
contains the haplotypes found in each sample (rows) for each gene
(columns). Each number in the haplotype indicates a position in the
amino acid chain, the letter before the number indicates the reference
allele (with sensitive phenotype), and the letter after the number is
the allele observed in the sample. If the letters are in capital
letters, that allele in that position has been previously reported as
resistant, whereas the letters in lower case indicate that it is the
first time that position has been reported as polymorphic. In case the
sample is polyclonal, each allele observed is separated by the following
symbol `|`, and the order in which they are reported is based on their
read count. Null data, defined as sections of the gene that have not
been amplified, are completed with the question mark `?`.

The second table contains the inferred phenotype for each sample (rows)
for each gene (columns). The third table contains the count of each
haplotype in the population (number of times observed) and its frequency
in the population (defined based on geographic and temporal
information). It is important to note that polyclonal samples are
included in this calculation, so the denominator is defined as the total
number of haplotypes found in the populations. Remember that if we run
this analysis after filtering not amplified samples and loci, some
polymorphism will not be included. To report all mutations included in
our panel of markers associated with drug resistance, we have to recover
that information from the slot `discarded_loci`.

```{r 'Molecular surveillance of drug resistance'}

gene_names = c('PfDHFR',
               'PfMDR1',
               'PfDHPS',
               'PfKelch13',
               'PF3D7_1447900')

gene_ids = c('PF3D7_0417200',
             'PF3D7_0523000',
             'PF3D7_0810800',
             'PF3D7_1343700',
             'PF3D7_1447900')

drugs = c('Artemisinine',
          'Chloroquine', 
          'Pyrimethamine',
          'Sulfadoxine',
          'Lumefantrine',
          'Mefloquine')

ampseq_drug = ampseq_filtered
    
ampseq_drug@gt = cbind(ampseq_drug@gt,
                       ampseq_drug@discarded_loci$gt[
                         rownames(ampseq_drug@discarded_loci$gt) %in%
                           rownames(ampseq_drug@gt),
                         grepl(paste0(gene_names, collapse = '|'),
                               colnames(ampseq_drug@discarded_loci$gt))]
                       )
    
ampseq_drug@markers = 
  rbind(ampseq_drug@markers,
        ampseq_drug@discarded_loci$markers[
          grepl(paste0(gene_names, collapse = '|'),
                ampseq_drug@discarded_loci$markers$amplicon),])
    
    

drug_resistant_haplotypes_plot = drug_resistant_haplotypes(
  ampseq_drug,
  reference_alleles = 'docs/reference/Pfal_3D7/drugR_alleles.csv',
  gene_names = gene_names,
  gene_ids = gene_ids,
  drugs = drugs,
  gff_file = "docs/reference/Pfal_3D7/PlasmoDB-59_Pfalciparum3D7.gff",
  fasta_file = "docs/reference/Pfal_3D7/PlasmoDB-59_Pfalciparum3D7_Genome.fasta",
  variables = c('Sample_id',
                'Subnational_level2',
                'Quarter_of_Collection'),
  Longitude = NULL,
  Latitude = NULL,
  na.var.rm = FALSE,
  na.hap.rm = TRUE,
  filters = c(
    'Subnational_level2;Municipality 1,Municipality 2,Municipality 3,Municipality 4,Municipality 5',
    'Quarter_of_Collection;2020-Q4,2021-Q1,2021-Q2,2021-Q3,2021-Q4,2022-Q1,2022-Q2,2022-Q3'))

```

The haplotype of each sample is stored in the table `aacigar_table`
within the object `drug_resistant_haplotypes_plot`.

```{r}
drug_resistant_haplotypes_plot$aa_mutations%>%datatable()
```

The phenotype of each sample, of each polymorphic position is in the
table `phenotype_table` within the object
`drug_resistant_haplotypes_plot`. The information of multiples positions
within the same marker is concatenated using `";"`.

```{r}
drug_resistant_haplotypes_plot$genotype_phenotype_table%>%datatable()
```

The colors assigned to the haplotypes in the bar blot are randomly
chosen, see below:

```{r, fig.width=12, fig.height=7}
drug_resistant_haplotypes_plot$haplotype_freq_barplot
```

However, we can manually assign colors based on the resistance profile
of the haplotype:

```{r 'Plot drug resistance', fig.width=12, fig.height=7, fig.cap='**Figure 4:** Frequency of haplotypes of genes associated with drug resistance. y-axis shows the frequency in the sub-population, x-axis shows the quarter of the year where the sample was collected, rows panels corresponds to the five study areas, and column panels represents each genotyped gene. Colors were assigned based on the possible phenotype, dark blue indicates sensitive, while dark red indicates resistance. Light colors where assigned for partial haplotype information, and gray for complete missging data'}


drug_resistant_haplotypes_plot$drug_phenotype_barplot

```

## Monitoring transmission intensity

The transmission of Malaria has an effect on the evolutionary processes
that affect the parasite population. Thus, various genetic indicators
are used to identify changes in the intensity of transmission at a
spatial and temporal level. One of these indicators is the prevalence of
polyclonal infections, or the coexistence of two or more different
clones (haplotypes) within the infected individual. As the human
parasite genome is haploid, the presence of a single haplotype is
expected. The presence of two or more different haplotypes in the sample
may be due to the transmission of two or more different genotypes from
the same bite (co-infection), or the acquisition of parasites by
multiple infections or independent bites (super-infection); and both
processes are related to the intensity of transmission. In low
transmission there are few infective bites, so there is little chance
that a person can acquire a super-infection or co-infection, and
therefore most infections are monoclonal. On the other hand, when the
necessary conditions exist for the increase in the mosquito population
and the interaction between it and the human is favored,
super-infections and co-infections increase, generating an increase in
the prevalence of polyclonal infections.

The genetic relatedness between parasites is also affected by the
intensity of transmission. As we mentioned previously, in low
transmission scenarios monoclonal infections are favored, so when an
infected person is bitten, a single haplotype is transmitted and
self-fertilization of the parasite occurs in the mosquito (sexual
reproduction of two genetically identical or related haplotypes). This
mechanism of propagation by inbreeding is called clonal propagation, and
it causes all the alleles of a haplotype to segregate together and not
independently, thus increasing the genetic relatedness in the
population.

The parasite effective population size (number of individuals in the
population that explains the magnitude of the effect of genetic drift in
the population) and its diversity, are also influenced by transmission.
The increase in transmission is a consequence of the reproductive
success of the different lineages of circulating parasites and the
increase in their effective population size. These circumstances
increase the introduction of new variants in the population (increase in
the population mutation rate or $\theta$), the number of polymorphic
sites, the richness of alleles of each polymorphic site (number of
alleles per locus), and genetic diversity in terms of heterozygosity of
the population (probability of selecting two different alleles by
chance). On the other hand, when transmission decreases and the
effective population size is reduced, and genetic drift causes the
random fixation of alleles, and the diversity of the population is
reduced. However, the effective size of the population and its diversity
are also strongly influenced by the introduction of new variants as a
result of migration and the genetic structure of the parasite
population, so the relationship between these metrics and transmission
is not linear.

### Complexity of infection and transmission

In this section we will focus on describing the relationship between the
intensity of transmission, inferred through the number of samples
collected, and the proportion of polyclonal infections. To do this, we
will first use the function `get_polygenomic` to identify polyclonal
infections, determine their complexity of infection (number of different
clones coexisting in the sample), and the number of heterozygous loci
per sample. This information is automatically added to the `metadata`
table of the ampseq_object. We will then proceed to describe the
distribution of heterozygous loci per sample, the COI, and the
proportion of polyclonal infections in each population. Finally, we will
describe the temporal change in the proportion of polyclonal infections
and its association with the number of samples collected.

```{r "Defining clonality of the samples"}
ampseq_filtered = get_polygenomic(ampseq_object = ampseq_filtered, 
                                  strata = "Subnational_level2",
                                  na.rm = FALSE,
                                  filters = NULL)
```

The function `get_polygenomic` generates 3 tables:

1.  A vector that describes for each loci the proportion of polyclonal
    samples detected. This vector is added to the loci_performance table
    in our ampseq_object if we set `update_popsummary = T`. This
    information is useful in order to identify genotyping errors that
    are not filtered out in the denoising pipeline and the
    identification of chimeras by dada2. That is the case of the alleles
    `PF3D7_1302900,1G` and `PF3D7_0612900,215A` for instance.

```{r}
ampseq_filtered@loci_performance %>% 
  select(loci, prop_poly_detected)%>%datatable(rownames = F)%>%
  formatRound(columns='prop_poly_detected', digits=3)
```

2.  A table that describes for each sample:

-   The number of heterozygous loci (NPolyLoci) or heterozygous
    amplicons in the sample.

-   The name of the heterozygous loci (Polyloci).

-   The observed alleles in each heterozygous loci (alleles_at_loci)
    where alleles within the same loci are separated by "\_", while
    alleles from different loci are separated by"/".

-   The number of alleles observed in each heterozygous loci
    (nalleles_per_loci) where values from different loci are separated
    by "/".

-   And finally the complexity of the infection (coi) defined as the
    maximum number of alleles observed in any of the heterozygous loci
    in the sample. As this definition is permissible as samples the only
    have one heterozygous loci can be considered polyclonal. The user
    can easily change that definition to a more stringent incorporating
    the information of the minimum number of heterozygous loci required
    to be considered polyclonal. In future updates we will incorporate
    the Within host divergence ($F_{ws}$) index.

    This table is added to the metadata table in our ampseq_object if we
    set `update_popsummary = T`.

```{r}
ampseq_filtered@metadata %>%
  select(Sample_id,NPolyLoci, Frac_PolyLoci, Polyloci, alleles_at_loci, nalleles_per_loci, coi)%>%
  datatable(rownames = F)
```

3.  Distribution of fraction of polyclonal loci per sample

```{r}

ampseq_filtered@metadata %>%
  ggplot(aes(x = Frac_PolyLoci))+
  geom_histogram(binwidth = 0.005)

```

3.  A pop summary table that summarize the mean COI in each population,
    the total number of polyclonal infections, and the proportion
    polyclonal infections with its confident intervals at 95%.

```{r}
ampseq_filtered@pop_summary%>%
  datatable(rownames = F) %>%
  formatRound(columns=c('mean_coi', 'prop_poly', 'prop_poly_lower', 'prop_poly_upper'),
              digits=3)
```

We can visually inspect all this information by using histograms. Here
is an example with the number of heterozygous loci per sample by
sampling location. We will use the function log_scale_histogram because
the number of samples with only one heterozygous loci is high with
respect to the number of samples with more than 10 heterozygous loci.

```{r 'Distribution of the number of heterozygous loci per sample by sampling location', fig.width=7, fig.height=4, fig.cap = '**Figure 5:** Distribution of the number of heterozygous loci per samples per population.'}

plot_log_NPolyLoci_by_pop = log_scale_histogram(data = ampseq_filtered@metadata[ampseq_filtered@metadata$NPolyLoci != 0,],
                                                var = "NPolyLoci", binwidth = 1, group_by = "Subnational_level2",
                                                levels = pop_levels, x_label = "Number of heterozygous loci per polyclonal sample",
                                                fill_color = pop_colors,
                                                y_breaks = c(1, 5,10, 30), ncol = 4)+
  labs(title = 'Distribution of # heterozygous loci per sample', 
       y = "# Samples",
       x = "# heterozygous loci per polyclonal sample")

plot_log_NPolyLoci_by_pop

```

We can do the same with the COI by sample.

```{r 'Distribution of COI by sampling location', fig.width=7, fig.height=4, fig.cap = '**Figure 6:** Distribution of the complexity of infection (COI) by study area. y-axis is in logarithm scale.'}

plot_log_coi_by_pop = log_scale_histogram(data = ampseq_filtered@metadata,
                                          var = "coi",
                                          binwidth = 1,
                                          group_by = "Subnational_level2",
                                          levels = pop_levels,
                                          x_label = "COI",
                                          fill_color = pop_colors,
                                          y_breaks = c(1,2, 5,10, 20, 50, 100,200, 400), ncol = 5)+
  labs(title = 'Distribution of COI by sampling location',
       y = "# Samples")

plot_log_coi_by_pop
```

In the case of the proportion of polyclonal infections by study area, we
can use a a barplot.

```{r 'Proportion of polyclonal infections by sampling location', fig.width=7, fig.height=4, fig.cap = '**Figure 7:** Proportion of polyclonal infections per study area.'}

plot_poly_by_pop = ampseq_filtered@pop_summary %>% ggplot(aes(x = factor(pop, levels = c(pop_levels, "Total")),
                                                          y = prop_poly,
                                                          fill = factor(pop, levels = c(pop_levels, "Total"))))+
  geom_col(alpha = .6) +
  geom_errorbar(aes(ymin = prop_poly_lower, ymax = prop_poly_upper), width = .2)+
  theme_bw() +
  labs(title = "Frequency of polyclonal infections",
       y = "Frecquency") +
  scale_fill_manual(values = c(pop_colors, "gray30"))+
  theme(axis.text = element_text(size = 12),
        axis.title = element_blank(),
        legend.position = "none")

plot_poly_by_pop
```

We can also explore temporal trends in the proportion of polyclonal
infections. First we are going to create a new variable in our metadata
concatenating the information of the study area (`Subnational_level2`)
and the information of the `Quarter_of_Collection`.

```{r}
ampseq_filtered@metadata %<>% mutate(Pop_quarter = paste(Subnational_level2, Quarter_of_Collection, sep = '_'))
```

Then we will use again the function `get_polygenomic`, using our new
variable in the slot of `strata` and the slot `filters` equals to
`'Municipality 1|Municipality 2|Municipality 3'`, in this way we will
just calculate the proportion of polyclonal infections for the
populations that have samples for most time points. As we don't want to
overwrite our previous analysis, we will set `update_popsummary = F` and
store the output in a new object.

```{r}
poly_by_pop_over_time = get_polygenomic(ampseq_object = ampseq_filtered,
                                        strata = "Pop_quarter",
                                        update_popsummary = F,
                                        na.rm = TRUE,
                                        filters = 'Municipality 1|Municipality 2|Municipality 3')

poly_by_pop_over_time$pop_summary %>% datatable() %>%
  formatRound(columns=c('mean_coi', 'prop_poly', 'prop_poly_lower', 'prop_poly_upper'),
              digits=3)

```

Now we can generate a bar plot using ggplot.

```{r 'Temporal change of complexity of infection', fig.width=7, fig.height=4, fig.cap = '**Figure 8:** Proportion of polyclonal infections per study area over year quarters.'}

plot_poly_by_pop_over_time = poly_by_pop_over_time$pop_summary %>%
  filter(pop != 'Total')%>%
  mutate(
  Population = stringr::str_split(pop, '_', simplify = TRUE)[,1],
  Date = stringr::str_split(pop, '_', simplify = TRUE)[,2],
  prop_poly_lower = case_when(
      prop_poly == 0 ~ 0,
      prop_poly != 0 ~ prop_poly_lower),
      prop_poly_upper = case_when(
        prop_poly == 0 ~ 0,
        prop_poly != 0 ~ prop_poly_upper)
  )%>%
  ggplot(aes(x = Date,
             y = prop_poly,
             ymin = prop_poly_lower,
             ymax = prop_poly_upper,
             fill = factor(Population, levels = pop_levels)))+
  geom_col()+
  geom_errorbar(width = .2)+
  facet_wrap(~factor(Population, levels = pop_levels), ncol = 5)+
  theme_bw()+
  scale_fill_manual(values = pop_colors)+
  labs(title = 'Temporal change of the proportion of polyclonal infections',
       y = "Polyclonal infections",
       x = "Date of Collection")+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.position =  "none")

plot_poly_by_pop_over_time
```

Finally, we can test if there is correlation between the proportion of
polyclonal infections and the number of collected samples per temporal
unit (as an approximation of the malaria burden).

For that we will joint our table `poly_by_pop_over_time` with a summary
of our metadata table.

```{r 'Correlation between the proportion of polyclonal infections and number of samples collected'}
nsamples_vs_proppoly = 
  left_join(poly_by_pop_over_time$pop_summary%>% 
              select(pop, prop_poly), metadata %>%
              mutate(Quarter_of_Collection = 
                       paste(substr(Date_of_Collection, 1, 4), quarters.Date(Date_of_Collection), sep='-')) %>%
              summarise(nsamples= n(), .by = c(Subnational_level2, Quarter_of_Collection)) %>% 
              mutate(pop = paste(Subnational_level2, Quarter_of_Collection, sep = '_')), by = 'pop') %>%
  filter(Subnational_level2 %in% c('Municipality 1', 'Municipality 2', 'Municipality 3'))
```

Then we can plot the correlation using the function `ggscatter`.

```{r, fig.width=7, fig.height=4, fig.cap= '**Figure 9:** Spearman correlation of the number of collected samples and proportion of polyclonal infections per year quarters. Each point represent the measurement of each year quarter in each study area.'}
plot_cor_proppoly_nsamples = ggscatter(nsamples_vs_proppoly, x = "prop_poly", y = "nsamples", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "spearman",
          title = '# Samples vs. Prop. Poly',
          xlab = "Proportion of polyclonal samples", ylab = "Number of samples", facet.by = 'Subnational_level2')

plot_cor_proppoly_nsamples
```

### Relatedness and Transmission

Relatedness is defined as the probability that, at any locus in the
genome, the alleles sampled from two different individuals are identical
by descent (IBD). A Hidden Markov Model based method was developed for
the estimation of relatedness (HMMIBD), where the relatedness or $r$ is
estimated as a function of the haplotype of the two sampled parasites
($Y_i$ and $Y_j$), the frequency of the alleles in the population, the
physical distance between loci, the recombination rate ($\rho$), a
switching rate of the Markov chain ($k$), and a constant genotyping
error rate ($\varepsilon$).

In this section we will measure the pairwise genetic relatedness, and
calculate the proportion of pairwise comparisons that have a relatedness
$\ge 0.99$ within and between operational units. For that we are going
to use the following functions:

1)  `pairwise_hmmIBD`: computes pairwise genetic relatedness using the
    HMMIBD algorithm implemented in [panlejugde R
    package](https://github.com/aimeertaylor/paneljudge). As an input it
    requires a `ampseq_object` and automatically all pairwise
    comparisons will be computed. Its output is a long format data.frame
    of all pairwise comparisons. This function is computationally
    exhaustive, so it has parallel argument to speed up the calculation.
    In the current example, the matrix is been generated separately in
    the cluster at Broadinstitute, and the `.csv` file is loaded by
    using the function `read.csv`.

```{r 'Estimating relatedness'}
# measuring relatedness----

if(file.exists('docs/data/Pfal_pairwise_relatedness.csv')){
  pairwise_relatedness = read.csv('docs/data/Pfal_pairwise_relatedness.csv')
}else{
  pairwise_relatedness = NULL
  
  for(w in 1:500){
    start = Sys.time()
    pairwise_relatedness = rbind(pairwise_relatedness,
                                 pairwise_hmmIBD(ampseq_filtered, parallel = T, w = w, n = 500))
    time_diff = Sys.time() - start
    
    print(paste0('step ', w, ' done in ', time_diff, ' secs'))
    
  }
  
  write.csv(pairwise_relatedness, 'docs/data/Pfal_pairwise_relatedness.csv', row.names = F, quote = F)
}
```

2)  `plot_relatedness_distribution`: visualizes the distribution of the
    pairwise relatedness within and between the different study areas.
    Its arguments are `relatedness_matrix`, `metadata`, `Population`,
    and `fill_color`.

```{r 'relatedness distribution within study areas', fig.width = 7, fig.height = 4, fig.cap = '**Figure 10:** Histogram of the distribution of pairwise genetic relatedness by study area (Panels). The dashed vertical line represents the average genetic relatedness in the overall population.'}

plot_relatedness_distribution_within = plot_relatedness_distribution(
  pairwise_relatedness = pairwise_relatedness,
  metadata = ampseq@metadata,
  Population = 'Subnational_level2',
  fill_color = pop_colors,
  type_pop_comparison = 'within',
  ncol = 5,
  pop_levels = pop_levels
)

plot_relatedness_distribution_within$plot
```

3)  Median fraction of IBD:

```{r}
c(median(pairwise_relatedness$rhat), IQR(pairwise_relatedness$rhat))
```

```{r}

plot_relatedness_distribution_within$relatedness %>%
  summarise(median_rhat = round(median(rhat), 2),
            iqr_rhat = round(IQR(rhat), 2),
            .by = c(Pop_comparison,Type_of_comparison))%>%
  DT::datatable()

```

3)  `plot_frac_highly_related`: visualizes the fraction of highly
    related haplotypes within and between study areas. It has the same
    arguments than the previous function plus `threshold` (minimum value
    to consider two samples to be highly related).

```{r 'highly related samples within study areas', fig.width = 7, fig.height = 4, fig.cap = '**Figure 11:** Proportion of highly related samples (IBD > 0.99) in each study area.'}
plot_frac_highly_related_within = plot_frac_highly_related(
  pairwise_relatedness = pairwise_relatedness,
  metadata = ampseq@metadata,
  Population = 'Subnational_level2',
  fill_color = pop_colors,
  threshold = 0.97, type_pop_comparison = 'within', pop_levels = pop_levels)

plot_frac_highly_related_within$plot
```

4)  Table

```{r}
plot_frac_highly_related_within$highly_related_table%>%
  DT::datatable()
```

4)  `plot_frac_highly_related_over_time`: visualizes the fraction of
    highly related haplotypes within and between study areas, and by a
    temporal variable. It has the same arguments than the previous
    function plus `threshold` (minimum value to consider two samples to
    be highly related).

```{r 'fraction of highly related samples over time (3 months intervals) within study areas', fig.width = 7, fig.height=10, fig.cap = '**Figure 12:** Proportion of highly related samples over year quarters in each study area.'}
plot_frac_highly_related_over_months_within = plot_frac_highly_related_over_time(pairwise_relatedness = pairwise_relatedness,
                                       metadata = ampseq@metadata,
                                       Population = c('Subnational_level2', 'Month_of_Collection'),
                                       fill_color = pop_colors,
                                       threshold = 0.99,
                                       type_pop_comparison = 'within',
                                       pop_levels = pop_levels, ncol = 1)

plot_frac_highly_related_over_months_within$plot_frac_highly_related
```

```{r 'Correlation between the proportion of highly related samples and number of samples collected', fig.width = 7, fig.height = 4, fig.cap = '**Figure 13:** Spearman correlation of the proportion of highly related samples per year quarter in each estudy area and the number of collected samples by passive case detection.'}
nsamples_vs_highlyR = left_join(plot_frac_highly_related_over_months_within$plot_frac_highly_related$data %>% mutate(pop = paste(Pop_comparison, Date_Yi, sep = '_'))%>%
                                   ungroup()%>%
                                  filter(!(Date_Yi %in%
                                             paste0('2022-0', 1:8)))%>%
                                   select(pop, prop),
          metadata %>%
  filter(!is.na(Subnational_level2)) %>%
  group_by(Subnational_level2, Month_of_Collection) %>%
  summarise(nsamples= n()) %>% mutate(pop = paste(Subnational_level2, Month_of_Collection, sep = '_')), by = 'pop')  %>%
  filter(prop != 0, Subnational_level2 %in% c('Municipality 1', 'Municipality 2', 'Municipality 3'))

plot_cor_highlyR_nsamples = ggscatter(nsamples_vs_highlyR, x = "prop", y = "nsamples", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "spearman",
          title= 'D) # Collected samples vs. Proportion of highly related samples',
          xlab = "Proportion of highly related samples", ylab = "Number of samples",
          facet.by = 'Subnational_level2')

plot_cor_highlyR_nsamples

```

5)  `plot_network`: creates a network representation of the pairwise
    relatedness information. The function requires 7 arguments: 1) the
    `pairwise_relatedness` a long format data.frame with all pairwise
    comparisons, 2) `threshold` to define the minimum prairwise
    relatedness to plot a branch between the two compared samples, 3) a
    `metadata` table containing the variables the we want to include in
    the plot, 4) `sample_id` name of the column in `metadata` table
    where sample ids are located, 5) `group_by` variable from `metadata`
    table that we are going to use to assign colors to the nodes in the
    network, 6) `levels` order of the elements of `group_by` variable,
    and finally 7) `colors` that are going to be assigned to each
    element from `group_by`, in this case one color per population.

```{r 'network', fig.width=5, fig.height=5, fig.cap = '**Figure 14:** Network representation of pairwise genetic relatedness between samples. Each node represents a sample, and branches are displayed only for pairwise comparisons with a relatedness greater than 0.99. Colors were assigned based on the sampling location: Municipality 1 (Red), Municipality 2 (Blue), Municipality 3 (Gold), Municipality 4 (Green), and Municipality 5 (Coral).'}

Relatedness_network = plot_network(pairwise_relatedness = pairwise_relatedness,
                               threshold = .99,
                               metadata = ampseq_filtered@metadata,
                               sample_id = 'Sample_id',
                               group_by = 'Subnational_level2',
                               levels = pop_levels,
                               colors = pop_colors
                              )

```

6)  `IBD_evectors`: calculates `k` eigenvectors using the pairwise
    relatedness information to identify the presence of population
    structure. The function requires 5 arguments: 1) the `ampseq` object
    from the metadata will be extracted, 2) the `pairwise_relatedness` a
    long format data.frame with all pairwise comparisons, 3) `k` the
    number of eigenvectors to calculate, 4) `Pop` a character indicating
    variable used to assign colors, and 5) the auxiliary exponent `q`.

```{r, fig.width=5, fig.height=5, fig.cap = '**Figure 15:** Princial Component Analysis of pairwise genetic relatedness between samples. Each dot represents a sample, and colors were assigned based on the sampling location: Municipality 1 (Red), Municipality 2 (Blue), Municipality 3 (Gold), Municipality 4 (Green), and Municipality 5 (Coral).'}

evectors_IBD = IBD_evectors(ampseq_object = ampseq_filtered, relatedness_table = pairwise_relatedness, k = nrow(ampseq_filtered@metadata), Pop = 'Subnational_level2', q = 2)


evectors_IBD$eigenvector %>% ggplot(aes(x = PC1, y = PC2, color = Subnational_level2))+
  geom_point(alpha = .7, size = 2) +
  stat_ellipse(level = .6)+
  theme_bw()+
  scale_color_manual(values = pop_colors)+
  labs(color = 'Municipalities',
       x = paste0('1st PC (', round(evectors_IBD$contrib[1],1), '%)'),
       y = paste0('2nd PC (', round(evectors_IBD$contrib[2],1), '%)'))
```

## Measuring geographic connectivity

Malaria transmission is heterogeneous throughout the Colombian
territory, and it is mainly concentrated in transmission foci where
demographic and environmental factors favor the interaction between the
two hosts of the parasite, humans and Anopheles mosquitoes.
Operationally, disease control units are defined based on sub-national
administrative divisions. The connectivity or dispersal pattern of the
parasite between these geographic units may limit progress in disease
control if activities are not properly coordinated. This connectivity is
mainly influenced by human movement, and can be inferred by estimating
the proportion of genetically closely related parasites between the
different areas.

We can use again the function `plot_relatedness_distribution` to create
histograms of the distribution of relatedness between samples from
different study sites. In this case, we are going to set
`type_pop_comparison = 'between'`.

```{r 'relatedness distribution between study areas', fig.width=7, fig.height=4, fig.cap = '**Figure 16:** Histogram distribution of pairwise genetic relatedness between sampling locations. Panels in columns correspond to the three study areas. The dotted vertical lines represent the average genetic relatedness in the whole population.'}

plot_relatedness_distribution_between = plot_relatedness_distribution(
  pairwise_relatedness = pairwise_relatedness,
  metadata = ampseq_filtered@metadata %>% mutate(Pop = gsub('unicipality ','', Subnational_level2)),
  Population = 'Pop',
  fill_color = rep('gray50', 10),
  type_pop_comparison = 'between',
  ncol = 5,
  pop_levels = c("M1-M2", "M1-M3", "M1-M4",
                  "M1-M5", "M2-M3", "M2-M4", 
                  "M2-M5", "M3-M4", "M3-M5", 
                  "M4-M5")
)

plot_relatedness_distribution_between$plot
```

Again the fraction of highly related haplotypes between sites can be
explored with the function `plot_frac_highly_related` and setting
`type_pop_comparison = 'between'`.

```{r 'highly related samples between study areas', fig.width=4, fig.height=4, fig.cap = '**Figure 17:** Proportion of highly related samples between sampling locations.'}

plot_frac_highly_related_between = plot_frac_highly_related(
  pairwise_relatedness = pairwise_relatedness,
  metadata = ampseq_filtered@metadata %>% mutate(Pop = gsub('unicipality ','', Subnational_level2)),
  Population = 'Pop',
  fill_color = rep('gray50', 10),
  threshold = 0.99, type_pop_comparison = 'between',
  pop_levels = c("M1-M2", "M1-M3", "M1-M4",
                  "M1-M5", "M2-M3", "M2-M4", 
                  "M2-M5", "M3-M4", "M3-M5", 
                  "M4-M5"))

plot_frac_highly_related_between$plot
```

```{r}
plot_frac_highly_related_between$highly_related_table%>%
  filter(grepl('M(1|2|3)-M(1|2|3)',Pop_comparison))%>%
  DT::datatable()

```

### Genetic diversity

```{r}

diversity = fx_pop_diversity(ampseq_object = ampseq_filtered, strata = 'Subnational_level2')

diversity %>% DT::datatable()

```

```{r}
polyclonas = get_polygenomic(ampseq_object, strata = '')
```
